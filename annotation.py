# def aggregate(node):
#     strategy = node["Strategy"]
#
#     # Sorted
#     if strategy == "Sorted":
#         result = "Performs the Sorted Aggregate operation. "
#
#         # Get attributes that the tuples are grouped by
#         if "Group Key" in node:
#             result += "The tuples are sorted by the following key(s): "
#
#             for key in node["Group Key"]:
#                 result += key + ", "
#
#             result += "then combined to produce result(s). "
#
#     # Hashed
#     elif strategy == "Hashed":
#         result = f"Performs the Hashed Aggregate operation. "
#
#         # Get attributes that the tuples are grouped by
#         if "Group Key" in node:
#             result += "The tuples are hashed by the following key(s): "
#
#             for key in node["Group Key"]:
#                 # Remove unnecessary strings
#                 result += key.replace("::text", "") + ", "
#
#             result += "into buckets, then combined to produce result(s). "
#
#     # Plain / Mixed
#     else:
#         result = f"Performs the Aggregate operation. "
#
#         if "Group Key" in node:
#             result += "The tuples are grouped by the following key(s): "
#
#             for key in node["Group Key"]:
#                 result += key + ", "
#
#             result += ", then combined to produce result(s). "
#
#     return result
#
#
# def append(node):
#     return f"Performs the Append operation. This combines the results of the child operations."
#
#
# def bitmap_heap_scan(node):
#     result = f"Performs the Bitmap Heap Scan operation. This takes a row location bitmap generated by " \
#              f"a Bitmap Index Scan on the {node['Relation Name']} relation, "
#
#     if 'Filter' in node:
#         filter_cond = node['Filter']
#     else:
#         filter_cond = None
#     if 'Recheck Cond' in node:
#         recheck_cond = node['Recheck Cond']
#     else:
#         recheck_cond = None
#
#     if filter_cond and recheck_cond:
#         result += f"then filters the tuples by {filter_cond} and {recheck_cond}."
#     elif filter_cond:
#         result += f"then filters the tuples by {filter_cond}."
#     elif recheck_cond:
#         result += f"then filters the tuples by {recheck_cond}."
#
#
# def default(node):
#     return f"Performs the {node['Node Type']} operation."
#
# # ATTRIBUTES = {'Aggregate': ['Group Key', 'Strategy', 'Filter'],
# #               'Append': [],
# #               'Bitmap Heap Scan': ['Alias', 'Rows Removed by Filter', 'Filter'],
# #               'Bitmap Index Scan': ['Index Name', 'Index Cond'],
# #               'BitmapAnd': [],
# #               'BitmapOr': [],
# #               'Custom Scan': [],
# #               'CTE Scan': ['Index Cond', 'CTE Name', 'Filter', 'Alias'],
# #               'Foreign Scan': [],
# #               'Function Scan': [],
# #               'Gather': [],
# #               'Gather Merge': ['Output'],
# #               'Group': ['Group Key', ],
# #               'GroupAggregate': [],
# #               'Hash': [],
# #               'HashAggregate': ['Group Key'],
# #               'Hash Join': ['Hash Cond', 'Output', 'Join Type'],
# #               'HashSetOp': [],
# #               'Incremental Sort': [],
# #               'Index-Only Scan': ['Relation Name', 'Index Cond', 'Index Name', 'Filter', 'Alias'],
# #               'Index Scan': ['Relation Name', 'Index Cond', 'Filter'],
# #               'Limit': ['Plan Rows'],
# #               'LockRows': [],
# #               'Materialize': [],
# #               'Merge Append': [],
# #               'Merge Join': ['Merge Cond', 'Join Type'],
# #               'MixedAggregate': [],
# #               'ModifyTable': [],
# #               'Nested Loop': ['Join Type', 'Join Filter', 'Rows Removed by Join Filter', 'Filter',
# #                               'Rows Removed by Filter'],
# #               'ProjectSet': [],
# #               'Recursive Union': [],
# #               'Result': [],
# #               'Sequential Scan': ['Relation Name', 'Alias', 'Filter'],
# #               'SetOp': ['Command'],
# #               'Sort': ['Sort Method', 'Sort Key'],
# #               'Subquery Scan': [],
# #               'TID Scan': [],
# #               'Unique': [],
# #               'Values Scan': [],
# #               'WindowAgg': [],
# #               'WorkTable Scan': []}

def build_annotation(root):
    result = []

    final = dfs(root, result)
    result.append(final[1])

    # print(root.info)

    return result


def dfs(root, result):
    tables = []

    tmp_string = ""

    if root.children:
        for child in root.children:
            tmp = dfs(child, result)
            tables.append(tmp[0])
            result.append(tmp[1])

    if root.op == 'Seq Scan':
        table = root.info['Relation Name']
        alias = root.info['Alias']
        tmp_string = "Perform sequential scan on table {} as {}".format(table, alias)
        return table, tmp_string

    elif root.op == 'Index Scan':
        table = root.info['Relation Name']
        alias = root.info['Alias']
        tmp_string = "Perform index scan on table {} as {} using index on {}".format(table, alias,
                                                                                     root.info['Index Name'])
        if 'Index Cond' in root.info:
            tmp_string += ' where {}'.format(root.info['Index Cond'])
        if 'Filter' in root.info:
            tmp_string += ' with filter {}'.format(root.info['Filter'])
        return table, tmp_string

    elif root.op == 'Index-Only Scan':
        table = root.info['Relation Name']
        alias = root.info['Alias']
        tmp_string = "Perform index only scan on table {} as {} using index on {}".format(table, alias,
                                                                                          root.info['Index Name'])
        if 'Index Cond' in root.info:
            tmp_string += ' where {}'.format(root.info['Index Cond'])
        if 'Filter' in root.info:
            tmp_string += ' with filter {}'.format(root.info['Filter'])
        return table, tmp_string

    elif root.op == 'Foreign Scan':
        table = root.info['Relation Name']
        alias = root.info['Alias']
        tmp_string = "Perform foreign scan on table {} from schema {} as {}".format(table, root.info['Schema'], alias)
        return table, tmp_string

    elif root.op == 'Subquery Scan':
        tmp_string = "Perform subquery scan on previous operation"
        if 'Filter' in root.info:
            tmp_string += ' with filter {}'.format(root.info['Filter'])
        return tables[0], tmp_string

    elif root.op == 'CTE Scan':
        table = root.info['CTE Name']
        alias = root.info['Alias']
        tmp_string = 'Perform CTE scan on table {} as {}'.format(table, alias)
        if 'Filter' in root.info:
            tmp_string += ' with filter {}'.format(root.info['Filter'])
        return table, tmp_string

    elif root.op == 'Function Scan':
        table = root.info['Schema']
        alias = root.info['Alias']
        tmp_string = 'Perform function {} on schema {} as {}'.format(root.info['Function Name'], table, alias)
        if 'Filter' in root.info:
            tmp_string += ' with filter {}'.format(root.info['Filter'])
        return table, tmp_string

    elif root.op == 'TID Scan':
        table = root.info['Relation Name']
        alias = root.info['Alias']
        tmp_string = 'Perform TID Scan on table {} as {}'.format(table, alias)
        return table, tmp_string

    elif root.op == 'Hash':
        tmp_string = "Perform hash on table {}".format(tables[0])
        return tables[0], tmp_string

    elif root.op == 'HashAggregate':
        tmp_string = 'Perform hash aggregate operation on table {}'.format(tables[0])
        return tables[0], tmp_string

    elif root.op == 'Aggregate':
        tmp_string = 'Perform aggregate on table {}'.format(tables[0])
        return tables[0], tmp_string

    elif root.op == 'Append':
        tmp_string = 'Append results from table {} to table {}'.format(tables[0], tables[1])
        return tables[0], tmp_string

    elif root.op == 'Gather':
        tmp_string = 'Perform gather operation on table {}'.format(tables[0])
        return tables[0], tmp_string

    elif root.op == 'Gather Merge':
        tmp_string = 'Perform gather merge operation on result of previous operations'
        return tables[0], tmp_string

    elif root.op == 'GroupAggregate':
        tmp_string = 'Perform group aggreagate operation on table {}'.format(tables[0])
        return tables[0], tmp_string

    elif root.op == 'Hash Join':
        tmp_string = "Perform hash join on tables {} and {}".format(tables[0], tables[1])
        return tables[0], tmp_string

    elif root.op == 'Nested Loop':
        tmp_string = 'Perform nested loop join on tables {} and {}'.format(tables[0], tables[1])
        if 'Filter' in root.info:
            tmp_string += ' with filter {}'.format(root.info['Filter'])
        if 'Join Filter' in root.info:
            tmp_string += ' with condition {}, {}, {}'.format(tables[0], tables[1], root.info['Join Filter'])
        return tables[0], tmp_string

    elif root.op == 'Merge Join':
        tmp_string = 'Perform merge join on tables {} and {}'.format(tables[0], tables[1])
        if 'Filter' in root.info:
            tmp_string += ' with filter {}'.format(root.info['Filter'])
        if 'Merge Cond' in root.info:
            tmp_string += ' with condition {}'.format(root.info['Merge Cond'])
        return tables[0], tmp_string

    elif root.op == 'Sort':
        tmp_string = 'Perform sort operation on table {} with sort key {}'.format(tables[0], root.info['Sort Key'])
        return tables[0], tmp_string

    elif root.op == 'Incremental Sort':
        tmp_string = 'Perform incremental sort operation on table {} with sort key {}'.format(tables[0],
                                                                                              root.info['Sort Key'])
        return tables[0], tmp_string

    elif root.op == 'Limit':
        tmp_string = 'Number of rows is limited from table {}'.format(tables[0])
        return tables[0], tmp_string

    elif root.op == 'Materialize':
        tmp_string = 'Perform materialize operation on table {}'.format(tables[0])
        return tables[0], tmp_string

    elif root.op == 'ModifyTable':
        table = root.info['Relation Name']
        tmp_string = 'Modify table {}'.format(table)
        return table, tmp_string

    elif root.op == 'MergeAppend':
        tmp_string = 'Merge results from table {} and {}'.format(tables[0], tables[1])
        return tables[0], tmp_string

    elif root.op == 'SetOp':
        tmp_string = 'Perform set operation on table {}'.format(tables[0])
        return tables[0], tmp_string

    elif root.op == 'Unique':
        table = ''
        if 'Subplan Name' in root.info:
            table = root.info['Subplan Name']
        else:
            table = tables[0]

        tmp_string = 'Remove duplicates from table {}'.format(table)

        return table, tmp_string
